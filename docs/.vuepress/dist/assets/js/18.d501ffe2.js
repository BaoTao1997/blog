(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{256:function(v,_,e){"use strict";e.r(_);var t=e(0),a=Object(t.a)({},function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"冒泡排序-bubble-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#冒泡排序-bubble-sort","aria-hidden":"true"}},[v._v("#")]),v._v(" 冒泡排序 Bubble Sort")]),v._v(" "),e("h3",{attrs:{id:"简明解释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简明解释","aria-hidden":"true"}},[v._v("#")]),v._v(" 简明解释")]),v._v(" "),e("p",[v._v("通过"),e("strong",[v._v("依次比较、交换相邻的元素大小")]),v._v("（按照由小到大的顺序，如果符合这个顺序就不用交换）。")]),v._v(" "),e("p",[e("em",[v._v("1 次这样的循环可以得到一个最大值，n - 1 次这样的循环可以排序完毕")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性","aria-hidden":"true"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),e("ul",[e("li",[v._v("稳定")]),v._v(" "),e("li",[v._v("时间复杂度 "),e("code",[v._v("O(n²)")])]),v._v(" "),e("li",[v._v("交换 "),e("code",[v._v("O(n²)")])]),v._v(" "),e("li",[v._v("对即将排序完成的数组进行排序 "),e("code",[v._v("O(n)")]),v._v("（但是这种情况下不如插入排序块，请继续看下文）")])]),v._v(" "),e("h3",{attrs:{id:"核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念","aria-hidden":"true"}},[v._v("#")]),v._v(" 核心概念")]),v._v(" "),e("ul",[e("li",[v._v("利用"),e("em",[v._v("交换，将最大的数冒泡到最后")])]),v._v(" "),e("li",[v._v("使用"),e("em",[v._v("缓存 postion")]),v._v(" 来优化")]),v._v(" "),e("li",[v._v("使用"),e("em",[v._v("双向遍历")]),v._v("来优化")])]),v._v(" "),e("h2",{attrs:{id:"选择排序-selection-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#选择排序-selection-sort","aria-hidden":"true"}},[v._v("#")]),v._v(" 选择排序 Selection Sort")]),v._v(" "),e("h3",{attrs:{id:"简明解释-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简明解释-2","aria-hidden":"true"}},[v._v("#")]),v._v(" 简明解释")]),v._v(" "),e("p",[e("strong",[v._v("每一次内循环遍历寻找最小的数")]),v._v("，记录下 "),e("code",[v._v("minIndex")]),v._v("，并"),e("em",[v._v("在这次内循环结束后交换 minIndex 和 i 的位置")]),v._v("。")]),v._v(" "),e("p",[v._v("重复这样的循环 "),e("code",[v._v("n - 1")]),v._v(" 次即得到结果。")]),v._v(" "),e("h3",{attrs:{id:"属性-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-2","aria-hidden":"true"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),e("ul",[e("li",[v._v("不稳定")]),v._v(" "),e("li",[e("code",[v._v("Θ(n²)")]),v._v(" 无论什么输入，均为 "),e("code",[v._v("Θ(n²)")])]),v._v(" "),e("li",[e("code",[v._v("Θ(n) 交换")]),v._v(": "),e("strong",[v._v("注意，这里只有 n 次的交换，选择排序的唯一优点")]),v._v("*")])]),v._v(" "),e("h2",{attrs:{id:"插入排序-insertion-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插入排序-insertion-sort","aria-hidden":"true"}},[v._v("#")]),v._v(" 插入排序 Insertion Sort")]),v._v(" "),e("p",[v._v("默认 "),e("em",[v._v("a[0] 为已排序数组中的元素")]),v._v("，"),e("em",[v._v("从 arr[1] 开始逐渐往已排序数组中插入元素")]),v._v("，"),e("strong",[v._v("从后往前一个个比较，如果待插入元素小于已排序元素，则已排序元素往后移动一位")]),v._v("，直到待插入元素找到合适的位置并插入已排序数组。")]),v._v(" "),e("p",[v._v("经过 "),e("code",[v._v("n - 1")]),v._v(" 次这样的循环插入后排序完毕。")]),v._v(" "),e("h3",{attrs:{id:"属性-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-3","aria-hidden":"true"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),e("ul",[e("li",[v._v("稳定")]),v._v(" "),e("li",[v._v("适合场景："),e("em",[v._v("对快要排序完成的数组时间复杂度为 O(n)")])]),v._v(" "),e("li",[e("em",[v._v("非常低的开销")])]),v._v(" "),e("li",[v._v("时间复杂度 "),e("code",[v._v("O(n²)")])])]),v._v(" "),e("blockquote",[e("p",[v._v("由于它的优点（自适应，低开销，稳定，几乎排序时的"),e("code",[v._v("O（n）")]),v._v("时间），插入排序通常用作递归基本情况（当问题规模较小时）针对较高开销分而治之排序算法， 如"),e("em",[v._v("希尔排序")]),v._v("或"),e("em",[v._v("快速排序")]),v._v("。")])]),v._v(" "),e("h3",{attrs:{id:"核心概念-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念-2","aria-hidden":"true"}},[v._v("#")]),v._v(" 核心概念")]),v._v(" "),e("ul",[e("li",[e("em",[v._v("高性能（特别是接近排序完毕时的数组），低开销，且稳定")])]),v._v(" "),e("li",[v._v("利用"),e("em",[v._v("二分查找")]),v._v("来优化")])]),v._v(" "),e("h2",{attrs:{id:"希尔排序-shell-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#希尔排序-shell-sort","aria-hidden":"true"}},[v._v("#")]),v._v(" 希尔排序 Shell Sort")]),v._v(" "),e("h3",{attrs:{id:"简明解释-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简明解释-3","aria-hidden":"true"}},[v._v("#")]),v._v(" 简明解释")]),v._v(" "),e("p",[v._v("希尔排序是"),e("em",[v._v("插入排序的改进版")]),v._v("，它"),e("strong",[v._v("克服了插入排序只能移动一个相邻位置的缺陷")]),v._v("（希尔排序可以一次移动 "),e("code",[v._v("gap")]),v._v(" 个距离），"),e("em",[v._v("利用了插入排序在排序几乎已经排序好的数组的非常快的优点")]),v._v("。")]),v._v(" "),e("p",[v._v("使用可以动态定义的 "),e("code",[v._v("gap")]),v._v(" 来渐进式排序，"),e("em",[v._v("先排序距离较远的元素，再逐渐递进")]),v._v("，而"),e("em",[v._v("实际上排序中元素最终位置距离初始位置远的概率是很大的")]),v._v("，所以希尔排序大大提升了性能（"),e("strong",[v._v("尤其是 reverse 的时候非常快")]),v._v("，想象一下这时候冒泡排序和插入排序的速度）。")]),v._v(" "),e("p",[v._v("而且希尔排序不仅效率较高（比冒泡和插入高），它的代码相对要简短，低开销（"),e("em",[v._v("继承插入排序的优点")]),v._v("），"),e("em",[v._v("追求这些特点（效率要求过得去就好，代码简短，开销低，且数据量较小）的时候希尔排序是好的 O(n·log(n)) 算法的替代品")]),v._v("。")]),v._v(" "),e("p",[v._v("总而言之：希尔排序的性能优化来自"),e("em",[v._v("增量队列的输入")]),v._v("和 "),e("em",[v._v("gap 的设定")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"属性-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-4","aria-hidden":"true"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),e("ul",[e("li",[v._v("不稳定")]),v._v(" "),e("li",[v._v("在快要排序完成的数组有 "),e("code",[v._v("O(n·log(n))")]),v._v(" 的时间复杂度（并且它对于反转数组的速度非常快）")]),v._v(" "),e("li",[e("code",[v._v("O(n^3/2)")]),v._v(" time as shown (想要了解更多细节，请查阅 "),e("a",{attrs:{href:"https://link.juejin.im?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FShellsort%23Applications",target:"_blank",rel:"noopener noreferrer"}},[v._v("wikipedia Shellsort"),e("OutboundLink")],1),v._v("）")])]),v._v(" "),e("h2",{attrs:{id:"归并排序-merge-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#归并排序-merge-sort","aria-hidden":"true"}},[v._v("#")]),v._v(" 归并排序 Merge Sort")]),v._v(" "),e("h3",{attrs:{id:"简明解释-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简明解释-4","aria-hidden":"true"}},[v._v("#")]),v._v(" 简明解释")]),v._v(" "),e("p",[v._v("归并排序使用"),e("em",[v._v("分而治之")]),v._v("的思想，以"),e("em",[v._v("折半")]),v._v("的方式来"),e("em",[v._v("递归/迭代")]),v._v("排序元素，利用空间来换时间，做到了时间复杂度 "),e("code",[v._v("O(n·log(n))")]),v._v(" 的同时保持了稳定。")]),v._v(" "),e("p",[v._v("这让它在一些更考虑排序效率和稳定性，"),e("em",[v._v("次考虑存储空间的场合非常适用")]),v._v("（如数据库内排序，和堆排序相比，归并排序的稳定是优点）。并且"),e("strong",[v._v("归并排序非常适合于链表排序")]),v._v("。")]),v._v(" "),e("h3",{attrs:{id:"属性-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-5","aria-hidden":"true"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),e("ul",[e("li",[v._v("稳定 ("),e("strong",[v._v("在 O(n·log(n)) 时间复杂度的排序算法中，归并排序是唯一稳定的")]),v._v(")")]),v._v(" "),e("li",[v._v("时间复杂度 "),e("code",[v._v("O(n·log(n))")])]),v._v(" "),e("li",[e("em",[v._v("对于数组需要 Θ(n) 的额外空间")]),v._v(" 注意："),e("em",[v._v("归并排序需要额外的空间，这是它的不完美之处")])]),v._v(" "),e("li",[e("em",[v._v("对于链表需要 O(log(n)) 的额外空间")]),v._v("，所以"),e("em",[v._v("归并排序非常适合列表的排序")])]),v._v(" "),e("li",[e("strong",[v._v("Does not require random access to data")]),v._v(" 因为这个特点，归并排序很适合用来排序列表")])]),v._v(" "),e("h3",{attrs:{id:"核心概念-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念-3","aria-hidden":"true"}},[v._v("#")]),v._v(" 核心概念")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("分而治之")]),v._v("的思想")]),v._v(" "),e("li",[e("em",[v._v("空间换时间，并且稳定")]),v._v("，"),e("em",[v._v("保持稳定性这一点是它的亮点")])]),v._v(" "),e("li",[e("em",[v._v("二分思想")])])]),v._v(" "),e("h2",{attrs:{id:"堆排序-heap-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#堆排序-heap-sort","aria-hidden":"true"}},[v._v("#")]),v._v(" 堆排序 Heap Sort")]),v._v(" "),e("h3",{attrs:{id:"简明解释-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简明解释-5","aria-hidden":"true"}},[v._v("#")]),v._v(" 简明解释")]),v._v(" "),e("p",[v._v("堆排序可以认为是"),e("em",[v._v("选择排序的改进版")]),v._v("，像选择排序一样"),e("em",[v._v("将输入划分为已排序和待排序")]),v._v("。")]),v._v(" "),e("p",[v._v("不一样的是堆排序"),e("em",[v._v("利用堆这种近似完全二叉树的良好的数据结构来实现排序")]),v._v("，本质上使用了"),e("em",[v._v("二分的思想")]),v._v("。")]),v._v(" "),e("ol",[e("li",[e("em",[v._v("先将所有的数据堆化")])]),v._v(" "),e("li",[e("em",[v._v("然后移动 arr[0] 到数组末尾（已排序区域）")])]),v._v(" "),e("li",[e("em",[v._v("再重新堆化")]),v._v("，依次这样循环来排序。")])]),v._v(" "),e("p",[v._v("利用堆这种良好的数据结构，它在拥有"),e("em",[v._v("良好的可预测性")]),v._v("的同时（不管输入什么都是 "),e("code",[v._v("O(n·log(n))")]),v._v(" 时间复杂度），"),e("em",[v._v("但它的缺点也有：即不稳定")]),v._v("，而且 "),e("code",[v._v("O(n·log(n))")]),v._v(" 的平均效率决定了它的效率不如快速排序。适用于数据库内引擎排序（需要这样的可预测性性能）。")]),v._v(" "),e("h3",{attrs:{id:"属性-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-6","aria-hidden":"true"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),e("ul",[e("li",[v._v("不稳定")]),v._v(" "),e("li",[v._v("O(n·log(n)) time")])]),v._v(" "),e("h3",{attrs:{id:"核心概念-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念-4","aria-hidden":"true"}},[v._v("#")]),v._v(" 核心概念")]),v._v(" "),e("ul",[e("li",[v._v("利用良好的数据结构——堆，来排序")]),v._v(" "),e("li",[v._v("二分的思想")]),v._v(" "),e("li",[v._v('选择排序的改进版，继承了"可预测性"（什么数据输入都为 '),e("code",[v._v("O(n·log(n)")]),v._v(" time）")])]),v._v(" "),e("h2",{attrs:{id:"快速排序-quick-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快速排序-quick-sort","aria-hidden":"true"}},[v._v("#")]),v._v(" 快速排序 Quick Sort")]),v._v(" "),e("h3",{attrs:{id:"简明解释-6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简明解释-6","aria-hidden":"true"}},[v._v("#")]),v._v(" 简明解释")]),v._v(" "),e("ol",[e("li",[v._v('从数列中挑出一个元素，称为"基准"（pivot），')]),v._v(" "),e("li",[v._v("重新排序数列，"),e("em",[v._v("所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面")]),v._v("（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为"),e("em",[v._v("分区（partition）操作")]),v._v("。")]),v._v(" "),e("li",[v._v("递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。")])]),v._v(" "),e("h3",{attrs:{id:"属性-7"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性-7","aria-hidden":"true"}},[v._v("#")]),v._v(" 属性")]),v._v(" "),e("ul",[e("li",[v._v("不稳定")]),v._v(" "),e("li",[v._v("O(n²) time, 但是通常都是 O(n·log(n)) time (或者更快)")]),v._v(" "),e("li",[v._v("O(log(n)) extra space")])]),v._v(" "),e("blockquote",[e("p",[e("em",[v._v("When implemented well, it can be about two or three times faster than its main competitors, merge sort and heap sort")])])]),v._v(" "),e("h3",{attrs:{id:"核心概念-5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#核心概念-5","aria-hidden":"true"}},[v._v("#")]),v._v(" 核心概念")]),v._v(" "),e("ul",[e("li",[v._v("使用了"),e("strong",[v._v("分而治之")]),v._v("的思想")])]),v._v(" "),e("h2",{attrs:{id:"总结-答疑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结-答疑","aria-hidden":"true"}},[v._v("#")]),v._v(" 总结 & 答疑")]),v._v(" "),e("p",[e("a",{attrs:{href:"../.vuepress/public/blog/data-structure-sort"}},[v._v("代码")])]),v._v(" "),e("p",[v._v("提出几个问题，可以当做自我检测：")]),v._v(" "),e("ul",[e("li",[v._v("数据几乎快排序完成时？")])]),v._v(" "),e("p",[v._v("插入排序不解释")]),v._v(" "),e("ul",[e("li",[v._v("数据量小，对效率要求不高，代码简单时？")])]),v._v(" "),e("p",[v._v("性能大小：希尔排序 > 插入排序 > 冒泡排序 > 选择排序")]),v._v(" "),e("ul",[e("li",[v._v("数据量大，要求稳定的效率（不会像快速排序一样有 "),e("code",[v._v("O(n²)")]),v._v(" 的情况）（如数据库中）？")])]),v._v(" "),e("p",[v._v("堆排序")]),v._v(" "),e("ul",[e("li",[v._v("数据量大，要求效率高，而且要稳定？")])]),v._v(" "),e("p",[v._v("归并排序")]),v._v(" "),e("ul",[e("li",[v._v("数据量大，要求最好的平均效率？")])]),v._v(" "),e("p",[v._v("性能大小：快速排序 > 堆排序 > 归并排序")]),v._v(" "),e("p",[v._v("因为虽然堆排序做到了 "),e("code",[v._v("O(n·log(n)")]),v._v("，而快速排序的最差情况是 "),e("code",[v._v("O(n²)")]),v._v("，但是快速排序的绝大部分时间的效率比 "),e("code",[v._v("O(n·log(n)")]),v._v(" 还要快，所以快速排序真的无愧于它的名字。（十分快速）")]),v._v(" "),e("ul",[e("li",[v._v("选择排序绝对没用吗？")])]),v._v(" "),e("p",[v._v("选择排序只需要 "),e("code",[v._v("O(n)")]),v._v(" 次交换，这一点它完爆冒泡排序。")]),v._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.im/post/5ab62ec36fb9a028cf326c49#heading-51",target:"_blank",rel:"noopener noreferrer"}},[v._v("优雅的 JavaScript 排序算法"),e("OutboundLink")],1)]),v._v(" "),e("p",[v._v("快速排序参考:"),e("a",{attrs:{href:"https://www.cnblogs.com/LIUYANZUO/p/5745306.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("js实现快速排序"),e("OutboundLink")],1)])])},[],!1,null,null,null);_.default=a.exports}}]);