---
title: TCP连接
date: 2019-03-25 20:58:31
tags: 计算机网络
categories: 
- 计算机网络
---

## TCP三次握手与四次挥手

OSI分层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层 

TCP/IP模型：应用层、传输层、网络层、网络接口层 

应用层协议(常用)：HTTP、RTSP、FTP 

传输层协议：TCP、UDP 

![三次握手](../.vuepress/public/blog/osi-tcp/2.png)

- 第一次握手：客户端发送**SYN**报文请求同步,同时进入**SYN-SENT**状态


- 第二次握手：服务端接受到syn包后,发送**ACK**报文用于确认,同时发送自己的**SYN**报文,进入**SYN-RCVD**状态


- 第三次握手：客户端收到服务端的**ACK+SYN**后,向服务端发送**ACK**报文确认收到,到此客户端和服务端建立连接,完成三次握手

![四次挥手](../.vuepress/public/blog/osi-tcp/3.png)

- 第一次挥手:客户端发送**FIN**报文,表示停止发送数据,进入**FIN-WAIT**状态
- 第二次挥手:服务端收到客户端的**FIN**报文,发送**ACK**报文表示确认,同时服务器进入**关闭等待**状态(此时客户端不再向服务器的方向发送数据，处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受)

>客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）

- 第三次挥手:服务端发送**FIN**报文,服务端发送最后的数据,所以会发送**ACK**报文进行确认
- 第四次挥手:客户端接受到服务端的**FIN**报文则发送**ACK**报文表示确认收到,进入**TIME-WAIT**状态,服务端收到客户端的**ACK**报文即结束TCP连接

>客户端就进入了TIME-WAIT（时间等待）状态时, 注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态

| 注释 | ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。 |
| :--: | ------------------------------------------------------------ |
| seq  | TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。 |
| ack  | 期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号 |
| ACK  | 仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效           |
| SYN  | SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。 |
| FIN  | FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 |

### Q1:为什么连接的时候是三次握手，关闭的时候却是四次握手?

A1:当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

### Q2: 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

A2:如果网络是不可靠的，有可能客户端发送的最后一个ACK丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### Q3:为什么不能用两次握手进行连接？

A3:3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
现在把三次握手改成仅需要两次握手，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号. 在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

### Q4: 如果已经建立了连接，但是客户端突然出现故障了怎么办？

A4:TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

拓展:[TCP协议——顺序问题、丢包问题、流量控制、拥塞控制](<https://blog.csdn.net/xiaokunzhang/article/details/80714094>)


## TCP与UDP的区别

- TCP协议是有连接的，有连接表示开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的
- TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性, UDP不保证
- TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信
- TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率
- TCP首部需要20个字节, UDP首部只需8个字节

常见应用场景:

**QQ**为例:
1.登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。 
2.和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。 
3.如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。